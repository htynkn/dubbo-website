<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 概念与架构</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/</link><description>Recent content in 概念与架构 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dubbo.apache.org/zh/docs/v3.0/concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 服务发现</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/service-discovery/</guid><description>
&lt;p>服务发现，即消费端自动发现服务之地列表的能力，是微服务框架需要具备的关键能力。Dubbo 提供了基于消费端的自动服务发现能力，其基本工作原理如下图：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/architecture.png" alt="//imgs/architecture.png">&lt;/p>
&lt;p>服务发现的一个核心组件是注册中心，Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。
因此，要启用服务发现，需要为 Dubbo 增加注册中心配置：&lt;/p>
&lt;p>以 dubbo-spring-boot-starter 使用方式为例，增加 registry 配置&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"># application.properties
dubbo
registry
address: zookeeper://127.0.0.1:2181
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="服务发现dubbo3-vs-dubbo2">服务发现（Dubbo3 vs Dubbo2）&lt;/h2>
&lt;p>就使用方式上而言，Dubbo3 与 Dubbo2 的服务发现配置是完全一致的，不需要改动什么内容。但就实现原理上而言，Dubbo3 引入了全新的服务发现模型 - 应用级服务发现，
在工作原理、数据格式上已完全不能兼容老版本服务发现。&lt;/p>
&lt;ul>
&lt;li>Dubbo3 应用级服务发现，以应用粒度组织地址数据&lt;/li>
&lt;li>Dubbo2 接口级服务发现，以接口粒度组织地址数据&lt;/li>
&lt;/ul>
&lt;p>Dubbo3 格式的 Provider 地址不能被 Dubbo2 的 Consumer 识别到，反之 Dubbo2 的消费者也不能订阅到 Dubbo3 Provider。&lt;/p>
&lt;ul>
&lt;li>对于新用户，我们提倡直接启用 Dubbo3 的默认行为，即启用应用级服务发现，参见《samples/应用级服务发现》；&lt;/li>
&lt;li>对于老用户，要面临如何平滑迁移到应用级服务发现的问题，考虑到老用户的规则如此之大，Dubbo3 默认保持了接口级地址发现的行为，这保证了老用户可以直接无感升级到 Dubbo3。
而如果要开启应用级服务发现，则需要通过配置显示开启（双注册、双订阅），具体开启与平滑迁移过程，可参见《migration/地址发现迁移指南》。&lt;/li>
&lt;/ul>
&lt;h2 id="应用级服务发现">应用级服务发现&lt;/h2>
&lt;p>概括来说，Dubbo3 引入的应用级服务发现主要有以下优势&lt;/p>
&lt;ul>
&lt;li>适配云原生微服务变革。云原生时代的基础设施能力不断向上释放，像 Kubernetes 等平台都集成了微服务概念抽象，Dubbo3 的应用级服务发现是适配各种微服务体系的通用模型。&lt;/li>
&lt;li>提升性能与可伸缩性。支持超大规模集群的服务治理一直以来都是 Dubbo 的优势，通过引入应用级服务发现模型，从本质上解决了注册中心地址数据的存储与推送压力，相应的 Consumer 侧的地址计算压力也成数量级下降；
集群规模也开始变得可预测、可评估（与 RPC 接口数量无关，只与实例部署规模相关）。&lt;/li>
&lt;/ul>
&lt;p>下图是 Dubbo2 的服务发现模型：Provider 注册服务地址，Consumer 经过注册中心协调并发现服务地址，进而对地址发起通信，这是被绝大多数微服务框架的经典服务发现流程。而 Dubbo2 的特殊之处在于，它把 “RPC 接口”的信息也融合在了地址发现过程中，而这部分信息往往是和具体的业务定义密切相关的。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/servicediscovery_old.png" alt="//imgs/v3/concepts/servicediscovery_old.png">&lt;/p>
&lt;p>而在接入云原生基础设施后，基础设施融入了微服务概念的抽象，容器化微服务被编排、调度的过程即
完成了在基础设施层面的注册。如下图所示，基础设施即承担了注册中心的职责，又完成了服务注册的动作，而 “RPC 接口”这部分信息，由于与具体的业务相关，不可能也不适合被基础设施托管。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/servicediscovery_k8s.png" alt="//imgs/v3/concepts/servicediscovery_k8s.png">&lt;/p>
&lt;p>在这样的场景下，对 Dubbo3 的服务注册发现机制提出了两个要求：
Dubbo3 需要在原有服务发现流程中抽象出通用的、与业务逻辑无关的地址映射模型，并确保这部分模型足够合理，以支持将地址的注册行为和存储委托给下层基础设施
Dubbo3 特有的业务接口同步机制，是 Dubbo3 需要保留的优势，需要在 1 中定义的新地址模型之上，通过框架内的自有机制予以解决。&lt;/p>
&lt;p>这样设计的全新的服务发现模型，在架构兼容性、可伸缩性上都给 Dubbo3 带来了更大的优势。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/servicediscovery_mem.png" alt="//imgs/v3/concepts/servicediscovery_mem.png">&lt;/p>
&lt;p>在架构兼容性上，如上文所述，Dubbo3 复用下层基础设施的服务抽象能力成为了可能；另一方面，如 Spring Cloud 等业界其它微服务解决方案也沿用这种模型，
在打通了地址发现之后，使得用户探索用 Dubbo 连接异构的微服务体系成为了一种可能。&lt;/p>
&lt;p>Dubbo3 服务发现模型更适合构建可伸缩的服务体系，这点要如何理解？
这里先举个简单的例子，来直观的对比 Dubbo2 与 Dubbo3 在地址发现流程上的数据流量变化：假设一个微服务应用定义了 100 个接口（Dubbo 中的服务），
则需要往注册中心中注册 100 个服务，如果这个应用被部署在了 100 台机器上，那这 100 个服务总共会产生 100 * 100 = 10000 个虚拟节点；而同样的应用，
对于 Dubbo3 来说，新的注册发现模型只需要 1 个服务（只和应用有关和接口无关）， 只注册和机器实例数相等的 1 * 100 = 100 个虚拟节点到注册中心。
在这个简单的示例中，Dubbo 所注册的地址数量下降到了原来的 1 / 100，对于注册中心、订阅方的存储压力都是一个极大的释放。更重要的是，
地址发现容量彻底与业务 RPC 定义解藕开来，整个集群的容量评估对运维来说将变得更加透明：部署多少台机器就会有多大负载，不会像 Dubbo2 一样，
因为业务 RPC 重构就会影响到整个集群服务发现的稳定性。&lt;/p>
&lt;p>请通过以下 blog 了解更多应用级服务发现设计原则细节。&lt;/p></description></item><item><title>Docs: RPC 通信协议</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/rpc-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/rpc-protocol/</guid><description>
&lt;p>RPC 协议&lt;/p>
&lt;h2 id="tripledubbo3">Triple（Dubbo3）&lt;/h2>
&lt;h2 id="dubbo2">Dubbo2&lt;/h2>
&lt;h2 id="其他协议">其他协议&lt;/h2></description></item><item><title>Docs: 服务流量管理</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/traffic-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/traffic-management/</guid><description>
&lt;h3 id="流量管理">流量管理&lt;/h3>
&lt;p>&lt;code>Dubbo&lt;/code>提供了强大的流量管理能力。流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/what-is-traffic-control.png" alt="What is traffic control">&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>路由规则可以有多个，不同的路由规则之间存在优先级。如：Router(1) -&amp;gt; Router(2) -&amp;gt; …… -&amp;gt; Router(n)&lt;/li>
&lt;li>一个路由规则可以路由到多个不同的应用服务。如：Router(2)即可以路由到Service(1)也可以路由到Service(2)&lt;/li>
&lt;li>多个不同的路由规则可以路由到同一个应用服务。如：Router(1)和Router(2)都可以路由到Service(2)&lt;/li>
&lt;li>路由规则也可以不路由到任何应用服务。如：Router(m)没有路由到任何一个Service上，所有命中Router(m)的请求都会因为没有对应的应用服务处理而导致报错&lt;/li>
&lt;li>应用服务可以是单个的实例，也可以是一个应用集群。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;p>&lt;code>Dubbo&lt;/code>支持生产上常用的流量应用场景。&lt;/p>
&lt;h5 id="蓝绿部署">蓝绿部署&lt;/h5>
&lt;p>蓝绿部署是让线上的老版本继续运行，直接部署新版本然后进行测试，当新版本测试通过以后，将流量切到新版本，最后将老版本同时也升级到新版本。整个过程无需停机，风险较小且可控。&lt;/p>
&lt;h5 id="ab测试">AB测试&lt;/h5>
&lt;p>AB测试是用来测试应用功能的一种方案。通过科学的实验设计、样本采样、流量分割和校验等方式来获得具有代表性的实验结论，并确信该结论再推广到全部流量可信。&lt;/p>
&lt;h5 id="金丝雀部署">金丝雀部署&lt;/h5>
&lt;p>金丝雀部署是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”，测试新版本的性能和表现，在保障整体系统稳定的前提下，尽早发现、及时调整。&lt;/p></description></item><item><title>Docs: 配置管理</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/configuration/</guid><description/></item><item><title>Docs: 部署架构（注册中心 配置中心 元数据中心）</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/registry-configcenter-metadata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/registry-configcenter-metadata/</guid><description>
&lt;p>作为一个微服务框架，Dubbo sdk 跟随着微服务组件被部署在分布式集群各个位置，为了在分布式环境下实现各个微服务组件间的协作，
Dubbo 定义了一些中心化组件，这包括：&lt;/p>
&lt;ul>
&lt;li>注册中心。协调 Consumer 与 Provider 之间的地址注册与发现&lt;/li>
&lt;li>配置中心。
&lt;ul>
&lt;li>存储 Dubbo 启动阶段的全局配置，保证配置的跨环境共享与全局一致性&lt;/li>
&lt;li>负责服务治理规则（路由规则、动态配置等）的存储与推送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元数据中心。
&lt;ul>
&lt;li>接收 Provider 上报的服务接口元数据，为 Admin 等控制台提供运维能力（如服务测试、接口文档等）&lt;/li>
&lt;li>作为服务发现机制的补充，提供额外的接口/方法级别配置信息的同步能力，相当于注册中心的额外扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="//imgs/v3/concepts/threecenters.png">&lt;/p>
&lt;p>上图完整的描述了 Dubbo 微服务组件与各个中心的交互过程。&lt;/p>
&lt;p>以上三个中心并不是运行 Dubbo 的必要条件，用户完全可以根据自身业务情况决定只启用其中一个或多个，以达到简化部署的目的。通常情况下，所有用户都会以独立的注册中心
开始 Dubbo 服务开发，而配置中心、元数据中心则会在微服务演进的过程中逐步的按需被引入进来。&lt;/p>
&lt;blockquote>
&lt;p>当然在 Dubbo + Mesh 的场景下，随着 Dubbo 服务注册能力的弱化，注册中心也不再是必选项，其职责开始被控制面取代。
请参见 Dubbo Mesh 方案的描述，ThinSDK 与 Proxyless Mesh。&lt;/p>
&lt;/blockquote>
&lt;h2 id="注册中心">注册中心&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-registry.png" alt="//imgs/v3/concepts/centers-registry.png">&lt;/p>
&lt;h2 id="配置中心">配置中心&lt;/h2>
&lt;p>类比 Spring Cloud Config同
&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-config.png" alt="//imgs/v3/concepts/centers-config.png">&lt;/p>
&lt;h2 id="元数据中心">元数据中心&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-metadata.png" alt="//imgs/v3/concepts/centers-metadata.png">&lt;/p></description></item><item><title>Docs: 如何扩展 Dubbo</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/extensibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/extensibility/</guid><description/></item></channel></rss>