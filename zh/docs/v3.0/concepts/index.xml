<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 概念与架构</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/</link><description>Recent content in 概念与架构 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dubbo.apache.org/zh/docs/v3.0/concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 服务发现</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/service-discovery/</guid><description>
&lt;p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。&lt;/p>
&lt;p>实现服务发现的方式有很多种，Dubbo 提供的是一种 Client-Based 的服务发现机制，通常还需要部署额外的第三方注册中心组件来协调服务发现过程，如常用的 Nacos、Consul、Zookeeper 等，Dubbo 自身也提供了对多种注册中心组件的对接，用户可以灵活选择。&lt;/p>
&lt;p>Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/architecture.png" alt="//imgs/architecture.png">&lt;/p>
&lt;p>服务发现的一个核心组件是注册中心，Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。
因此，要启用服务发现，需要为 Dubbo 增加注册中心配置：&lt;/p>
&lt;p>以 dubbo-spring-boot-starter 使用方式为例，增加 registry 配置&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"># application.properties
dubbo
registry
address: zookeeper://127.0.0.1:2181
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="whats-new-in-dubbo3">What&amp;rsquo;s New in Dubbo3&lt;/h2>
&lt;p>就使用方式上而言，Dubbo3 与 Dubbo2 的服务发现配置是完全一致的，不需要改动什么内容。但就实现原理上而言，Dubbo3 引入了全新的服务发现模型 - 应用级服务发现，
在工作原理、数据格式上已完全不能兼容老版本服务发现。&lt;/p>
&lt;ul>
&lt;li>Dubbo3 应用级服务发现，以应用粒度组织地址数据&lt;/li>
&lt;li>Dubbo2 接口级服务发现，以接口粒度组织地址数据&lt;/li>
&lt;/ul>
&lt;p>Dubbo3 格式的 Provider 地址不能被 Dubbo2 的 Consumer 识别到，反之 Dubbo2 的消费者也不能订阅到 Dubbo3 Provider。&lt;/p>
&lt;ul>
&lt;li>对于新用户，我们提倡直接启用 Dubbo3 的默认行为，即启用应用级服务发现，参见《samples/应用级服务发现》；&lt;/li>
&lt;li>对于老用户，要面临如何平滑迁移到应用级服务发现的问题，考虑到老用户的规模如此之大，Dubbo3 默认保持了接口级地址发现的行为，这保证了老用户可以直接无感升级到 Dubbo3。
而如果要开启应用级服务发现，则需要通过配置显示开启（双注册、双订阅），具体开启与平滑迁移过程，可参见《migration/地址发现迁移指南》。&lt;/li>
&lt;/ul>
&lt;h2 id="应用级服务发现简介">应用级服务发现简介&lt;/h2>
&lt;p>概括来说，Dubbo3 引入的应用级服务发现主要有以下优势&lt;/p>
&lt;ul>
&lt;li>适配云原生微服务变革。云原生时代的基础设施能力不断向上释放，像 Kubernetes 等平台都集成了微服务概念抽象，Dubbo3 的应用级服务发现是适配各种微服务体系的通用模型。&lt;/li>
&lt;li>提升性能与可伸缩性。支持超大规模集群的服务治理一直以来都是 Dubbo 的优势，通过引入应用级服务发现模型，从本质上解决了注册中心地址数据的存储与推送压力，相应的 Consumer 侧的地址计算压力也成数量级下降；集群规模也开始变得可预测、可评估（与 RPC 接口数量无关，只与实例部署规模相关）。&lt;/li>
&lt;/ul>
&lt;p>下图是 Dubbo2 的服务发现模型：Provider 注册服务地址，Consumer 经过注册中心协调并发现服务地址，进而对地址发起通信，这是被绝大多数微服务框架的经典服务发现流程。而 Dubbo2 的特殊之处在于，它把 “RPC 接口”的信息也融合在了地址发现过程中，而这部分信息往往是和具体的业务定义密切相关的。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/servicediscovery_old.png" alt="//imgs/v3/concepts/servicediscovery_old.png">&lt;/p>
&lt;p>而在接入云原生基础设施后，基础设施融入了微服务概念的抽象，容器化微服务被编排、调度的过程即
完成了在基础设施层面的注册。如下图所示，基础设施即承担了注册中心的职责，又完成了服务注册的动作，而 “RPC 接口”这部分信息，由于与具体的业务相关，不可能也不适合被基础设施托管。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/servicediscovery_k8s.png" alt="//imgs/v3/concepts/servicediscovery_k8s.png">&lt;/p>
&lt;p>在这样的场景下，对 Dubbo3 的服务注册发现机制提出了两个要求：
Dubbo3 需要在原有服务发现流程中抽象出通用的、与业务逻辑无关的地址映射模型，并确保这部分模型足够合理，以支持将地址的注册行为和存储委托给下层基础设施
Dubbo3 特有的业务接口同步机制，是 Dubbo3 需要保留的优势，需要在 1 中定义的新地址模型之上，通过框架内的自有机制予以解决。&lt;/p>
&lt;p>这样设计的全新的服务发现模型，在架构兼容性、可伸缩性上都给 Dubbo3 带来了更大的优势。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/servicediscovery_mem.png" alt="//imgs/v3/concepts/servicediscovery_mem.png">&lt;/p>
&lt;p>在架构兼容性上，如上文所述，Dubbo3 复用下层基础设施的服务抽象能力成为了可能；另一方面，如 Spring Cloud 等业界其它微服务解决方案也沿用这种模型，
在打通了地址发现之后，使得用户探索用 Dubbo 连接异构的微服务体系成为了一种可能。&lt;/p>
&lt;p>Dubbo3 服务发现模型更适合构建可伸缩的服务体系，这点要如何理解？
这里先举个简单的例子，来直观的对比 Dubbo2 与 Dubbo3 在地址发现流程上的数据流量变化：假设一个微服务应用定义了 100 个接口（Dubbo 中的服务），
则需要往注册中心中注册 100 个服务，如果这个应用被部署在了 100 台机器上，那这 100 个服务总共会产生 100 * 100 = 10000 个虚拟节点；而同样的应用，
对于 Dubbo3 来说，新的注册发现模型只需要 1 个服务（只和应用有关和接口无关）， 只注册和机器实例数相等的 1 * 100 = 100 个虚拟节点到注册中心。
在这个简单的示例中，Dubbo 所注册的地址数量下降到了原来的 1 / 100，对于注册中心、订阅方的存储压力都是一个极大的释放。更重要的是，
地址发现容量彻底与业务 RPC 定义解藕开来，整个集群的容量评估对运维来说将变得更加透明：部署多少台机器就会有多大负载，不会像 Dubbo2 一样，
因为业务 RPC 重构就会影响到整个集群服务发现的稳定性。&lt;/p>
&lt;p>请通过以下 blog 了解更多应用级服务发现设计原则细节。&lt;/p></description></item><item><title>Docs: RPC 通信协议</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/rpc-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/rpc-protocol/</guid><description>
&lt;p>RPC 协议&lt;/p>
&lt;h2 id="tripledubbo3">Triple（Dubbo3）&lt;/h2>
&lt;h2 id="dubbo2">Dubbo2&lt;/h2>
&lt;h2 id="其他协议">其他协议&lt;/h2></description></item><item><title>Docs: 服务流量管理</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/traffic-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/traffic-management/</guid><description>
&lt;h3 id="流量管理">流量管理&lt;/h3>
&lt;p>流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/what-is-traffic-control.png" alt="What is traffic control">&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>路由规则可以有多个，不同的路由规则之间存在优先级。如：Router(1) -&amp;gt; Router(2) -&amp;gt; …… -&amp;gt; Router(n)&lt;/li>
&lt;li>一个路由规则可以路由到多个不同的应用服务。如：Router(2)即可以路由到Service(1)也可以路由到Service(2)&lt;/li>
&lt;li>多个不同的路由规则可以路由到同一个应用服务。如：Router(1)和Router(2)都可以路由到Service(2)&lt;/li>
&lt;li>路由规则也可以不路由到任何应用服务。如：Router(m)没有路由到任何一个Service上，所有命中Router(m)的请求都会因为没有对应的应用服务处理而导致报错&lt;/li>
&lt;li>应用服务可以是单个的实例，也可以是一个应用集群。&lt;/li>
&lt;/ul>
&lt;h3 id="dubbo流量管理介绍">Dubbo流量管理介绍&lt;/h3>
&lt;p>Dubbo提供了支持mesh方式的流量管理策略，可以很容易实现 &lt;a href="../../examples/routing/ab-testing-deployment/">A/B测试&lt;/a>、&lt;a href="../../examples/routing/canary-deployment/">金丝雀发布&lt;/a>、&lt;a href="../../examples/routing/blue-green-deployment/">蓝绿发布&lt;/a>等能力。&lt;/p>
&lt;p>Dubbo将整个流量管理分成&lt;a href="../../references/routers/virtualservice/">VirtualService&lt;/a>和&lt;a href="../../references/routers/destination-rule/">DestinationRule&lt;/a>两部分。当Consumer接收到一个请求时，会根据&lt;a href="../../references/routers/virtualservice/">VirtualService&lt;/a>中定义的&lt;a href="../../references/routers/virtualservice/#dubboroute">DubboRoute&lt;/a>和&lt;a href="../../references/routers/virtualservice/#dubboroutedetail">DubboRouteDetail&lt;/a>匹配到对应的&lt;a href="../../references/routers/virtualservice/#dubbodestination">DubboDestination&lt;/a>中的&lt;a href="../../references/routers/destination-rule/#subset">subnet&lt;/a>，最后根据&lt;a href="../../references/routers/destination-rule/">DestinationRule&lt;/a>中配置的&lt;a href="../../references/routers/destination-rule/#subset">subnet&lt;/a>信息中的labels找到对应需要具体路由的Provider集群。其中：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../references/routers/virtualservice/">VirtualService&lt;/a>主要处理入站流量分流的规则，支持服务级别和方法级别的分流。&lt;/li>
&lt;li>&lt;a href="../../references/routers/virtualservice/#dubboroute">DubboRoute&lt;/a>主要解决服务级别的分流问题。同时，还提供的重试机制、超时、故障注入、镜像流量等能力。&lt;/li>
&lt;li>&lt;a href="../../references/routers/virtualservice/#dubboroutedetail">DubboRouteDetail&lt;/a>主要解决某个服务中方法级别的分流问题。支持方法名、方法参数、参数个数、参数类型、header等各种维度的分流能力。同时也支持方法级的重试机制、超时、故障注入、镜像流量等能力。&lt;/li>
&lt;li>&lt;a href="../../references/routers/virtualservice/#dubbodestination">DubboDestination&lt;/a>用来描述路由流量的目标地址，支持host、port、subnet等方式。&lt;/li>
&lt;li>&lt;a href="../../references/routers/destination-rule/">DestinationRule&lt;/a>主要处理目标地址规则，可以通过hosts、&lt;a href="../../references/routers/destination-rule/#subset">subnet&lt;/a>等方式关联到Provider集群。同时可以通过&lt;a href="../../references/routers/destination-rule/#trafficpolicy">trafficPolicy&lt;/a>来实现负载均衡。&lt;/li>
&lt;/ul>
&lt;p>这种设计理念很好的解决流量分流和目标地址之间的耦合问题。不仅将配置规则进行了简化有效避免配置冗余的问题，还支持&lt;a href="../../references/routers/virtualservice/">VirtualService&lt;/a>和&lt;a href="../../references/routers/destination-rule/">DestinationRule&lt;/a>的任意组合，可以非常灵活的支持各种业务使用场景。&lt;/p></description></item><item><title>Docs: 配置管理</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/configuration/</guid><description/></item><item><title>Docs: 部署架构（注册中心 配置中心 元数据中心）</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/registry-configcenter-metadata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/registry-configcenter-metadata/</guid><description>
&lt;p>作为一个微服务框架，Dubbo sdk 跟随着微服务组件被部署在分布式集群各个位置，为了在分布式环境下实现各个微服务组件间的协作，
Dubbo 定义了一些中心化组件，这包括：&lt;/p>
&lt;ul>
&lt;li>注册中心。协调 Consumer 与 Provider 之间的地址注册与发现&lt;/li>
&lt;li>配置中心。
&lt;ul>
&lt;li>存储 Dubbo 启动阶段的全局配置，保证配置的跨环境共享与全局一致性&lt;/li>
&lt;li>负责服务治理规则（路由规则、动态配置等）的存储与推送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元数据中心。
&lt;ul>
&lt;li>接收 Provider 上报的服务接口元数据，为 Admin 等控制台提供运维能力（如服务测试、接口文档等）&lt;/li>
&lt;li>作为服务发现机制的补充，提供额外的接口/方法级别配置信息的同步能力，相当于注册中心的额外扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="//imgs/v3/concepts/threecenters.png">&lt;/p>
&lt;p>上图完整的描述了 Dubbo 微服务组件与各个中心的交互过程。&lt;/p>
&lt;p>以上三个中心并不是运行 Dubbo 的必要条件，用户完全可以根据自身业务情况决定只启用其中一个或多个，以达到简化部署的目的。通常情况下，所有用户都会以独立的注册中心
开始 Dubbo 服务开发，而配置中心、元数据中心则会在微服务演进的过程中逐步的按需被引入进来。&lt;/p>
&lt;blockquote>
&lt;p>当然在 Dubbo + Mesh 的场景下，随着 Dubbo 服务注册能力的弱化，注册中心也不再是必选项，其职责开始被控制面取代。
请参见 Dubbo Mesh 方案的描述，ThinSDK 与 Proxyless Mesh。&lt;/p>
&lt;/blockquote>
&lt;h2 id="注册中心">注册中心&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-registry.png" alt="//imgs/v3/concepts/centers-registry.png">&lt;/p>
&lt;h2 id="配置中心">配置中心&lt;/h2>
&lt;p>类比 Spring Cloud Config同
&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-config.png" alt="//imgs/v3/concepts/centers-config.png">&lt;/p>
&lt;h2 id="元数据中心">元数据中心&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-metadata.png" alt="//imgs/v3/concepts/centers-metadata.png">&lt;/p></description></item><item><title>Docs: 如何扩展 Dubbo</title><link>https://dubbo.apache.org/zh/docs/v3.0/concepts/extensibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs/v3.0/concepts/extensibility/</guid><description>
&lt;h2 id="扩展设计理念">扩展设计理念&lt;/h2>
&lt;p>可扩展性是任何一个系统所追求的，对于 Dubbo 来说是同样适用。&lt;/p>
&lt;h3 id="什么是可扩展性">什么是可扩展性&lt;/h3>
&lt;p>可扩展性是一种设计理念，代表了我们对未来的一种预想，我们希望在现有的架构或设计基础上，当未来某些方面发生变化的时候，我们能够以最小的改动来适应这种变化。&lt;/p>
&lt;h3 id="可扩展性的优点">可扩展性的优点&lt;/h3>
&lt;p>可扩展性的优点主要表现模块之间解耦，它符合开闭原则，对扩展开放，对修改关闭。当系统增加新功能时，不需要对现有系统的结构和代码进行修改，仅仅新增一个扩展即可。&lt;/p>
&lt;h3 id="扩展实现方式">扩展实现方式&lt;/h3>
&lt;p>一般来说，系统会采用 Factory、IoC、OSGI 等方式管理扩展(插件)生命周期。考虑到 Dubbo 的适用面，不想强依赖 Spring 等 IoC 容器。
而自己造一个小的 IoC 容器，也觉得有点过度设计，所以选择最简单的 Factory 方式管理扩展(插件)。在 Dubbo 中，所有内部实现和第三方实现都是平等的。&lt;/p>
&lt;h3 id="dubbo-中的可扩展性">Dubbo 中的可扩展性&lt;/h3>
&lt;ul>
&lt;li>平等对待第三方的实现。在 Dubbo 中，所有内部实现和第三方实现都是平等的，用户可以基于自身业务需求，替换 Dubbo 提供的原生实现。&lt;/li>
&lt;li>每个扩展点只封装一个变化因子，最大化复用。每个扩展点的实现者，往往都只是关心一件事。如果用户有需求需要进行扩展，那么只需要对其关注的扩展点进行扩展就好，极大的减少用户的工作量。&lt;/li>
&lt;/ul>
&lt;h2 id="dubbo-扩展的特性">Dubbo 扩展的特性&lt;/h2>
&lt;p>Dubbo 中的扩展能力是从 JDK 标准的 SPI 扩展点发现机制加强而来，它改进了 JDK 标准的 SPI 以下问题：&lt;/p>
&lt;ul>
&lt;li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。&lt;/li>
&lt;li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。&lt;/li>
&lt;/ul>
&lt;p>用户能够基于 Dubbo 提供的扩展能力，很方便基于自身需求扩展其他协议、过滤器、路由等。下面介绍下 Dubbo 扩展能力的特性。&lt;/p>
&lt;ul>
&lt;li>按需加载。Dubbo 的扩展能力不会一次性实例化所有实现，而是用那个扩展类则实例化那个扩展类，减少资源浪费。&lt;/li>
&lt;li>增加扩展类的 IOC 能力。Dubbo 的扩展能力并不仅仅只是发现扩展服务实现类，而是在此基础上更进一步，如果该扩展类的属性依赖其他对象，则 Dubbo 会自动的完成该依赖对象的注入功能。&lt;/li>
&lt;li>增加扩展类的 AOP 能力。Dubbo 扩展能力会自动的发现扩展类的包装类，完成包装类的构造，增强扩展类的功能。&lt;/li>
&lt;li>具备动态选择扩展实现的能力。Dubbo 扩展会基于参数，在运行时动态选择对应的扩展类，提高了 Dubbo 的扩展能力。&lt;/li>
&lt;li>可以对扩展实现进行排序。能够基于用户需求，指定扩展实现的执行顺序。&lt;/li>
&lt;li>提供扩展点的 Adaptive 能力。该能力可以使的一些扩展类在 consumer 端生效，一些扩展类在 provider 端生效。&lt;/li>
&lt;/ul>
&lt;p>从 Dubbo 扩展的设计目标可以看出，Dubbo 实现的一些例如动态选择扩展实现、IOC、AOP 等特性，能够为用户提供非常灵活的扩展能力。&lt;/p>
&lt;h2 id="dubbo-扩展加载流程">Dubbo 扩展加载流程&lt;/h2>
&lt;p>Dubbo 加载扩展的整个流程如下：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/extension-load.png" alt="//imgs/v3/concepts/extension-load.png">&lt;/p>
&lt;p>主要步骤为 4 个：&lt;/p>
&lt;ul>
&lt;li>读取并解析配置文件&lt;/li>
&lt;li>缓存所有扩展实现&lt;/li>
&lt;li>基于用户执行的扩展名，实例化对应的扩展实现&lt;/li>
&lt;li>进行扩展实例属性的 IOC 注入以及实例化扩展的包装类，实现 AOP 特性&lt;/li>
&lt;/ul>
&lt;h2 id="如何使用-dubbo-扩展能力进行扩展">如何使用 Dubbo 扩展能力进行扩展&lt;/h2>
&lt;p>下面以扩展注册中心为例进行说明如何利用 Dubbo 提供的扩展能力扩展 Triple 协议。&lt;/p>
&lt;p>(1) 在协议的实现 jar 包内放置文本文件：META-INF/dubbo/org.apache.dubbo.remoting.api.WireProtocol&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">tri=org.apache.dubbo.remoting.api.WireProtocol
&lt;/code>&lt;/pre>&lt;/div>&lt;p>(2) 实现类内容&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Activate&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">TripleHttp2Protocol&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> Http2WireProtocol &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明下：Http2WireProtocol 实现了 WireProtocol 接口&lt;/p>
&lt;p>(3) Dubbo 配置模块中，扩展点均有对应配置属性或标签，通过配置指定使用哪个扩展实现。比如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">&amp;lt;dubbo:protocol name=&amp;#34;tri&amp;#34; /&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的扩展步骤可以看出，用户基本在黑盒下就完成了扩展。&lt;/p>
&lt;h2 id="dubbo-扩展的应用">Dubbo 扩展的应用&lt;/h2>
&lt;p>Dubbo 的扩展能力非常灵活，在自身功能的实现上无处不在。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/extension-use.png" alt="//imgs/v3/concepts/extension-use.png">&lt;/p>
&lt;p>Dubbo 扩展能力使得 Dubbo 项目很方便的切分成一个一个的子模块，实现热插拔特性。用户完全可以基于自身需求，替换 Dubbo 原生实现，来满足自身业务需求。&lt;/p>
&lt;h2 id="使用场景">使用场景&lt;/h2>
&lt;ul>
&lt;li>如果你需要自定义负载均衡策略，你可以使用 Dubbo 扩展能力。&lt;/li>
&lt;li>如果你需要实现自定义的注册中心，你可以使用 Dubbo 扩展能力。&lt;/li>
&lt;li>如果你需要实现自定义的过滤器，你可以使用 Dubbo 扩展能力。&lt;/li>
&lt;/ul>
&lt;p>Dubbo 扩展平等的对待内部实现和第三方实现。更多使用场景，参见 &lt;a href="../references/">SPI 扩展实现&lt;/a>&lt;/p></description></item></channel></rss>